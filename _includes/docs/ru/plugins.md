## API плагинов

Допустим у нас есть приложение такого вида:

    express = require 'express'
    app = express.createServer()
    app.use express.bodyParser()
    app.use express.static "#{__dirname}/static"
    app.listen 3000

    ArticleSchema = new mongoose.Schema
        title : String
        body  : String

    ArticleModel = mongoose.model 'Articles', ArticleSchema

    resource = colibri.createResource
        model : ArticleModel


Мы создали "голый" REST-ресурс по адресу `/articles/`.
Он умеет отдавать статьи и списки статей, редактировать и удалять статьи.

Отлично, но мы не хотим, чтобы неавторизованные пользователи могли изменять наши статьи.

Допустим, система авторизации уже есть
(ни Colibri, ни Express не предоставляют таковой "из коробки",
но есть отличные сторонние решения),
а также предположим, что эта система добавляет переменные `req.isAuthorized` и `req.currentUser`.

Тогда мы должны написать плагин для нашего ресурса, который бы проверял `req.isAuthorized` и отвечал HTTP-кодом `403`, если пользователь не авторизован.

Проверять авторизацию будет обычная прослойка (middleware) для Express:

    isAuthorized = (req, res, next)->
        return res.send 403 unless req.isAuthorized
        next null

Теперь надо добавить её во все HTTP-методы нашего ресурса, которые мы хотим защитить:

    resource.use
        post:
            begin: isAuthorized
        del:
            begin: isAuthorized
        put:
            begin: isAuthorized

Что всё это значит? У каждого HTTP-метода в Colibri-ресурсе есть
последовательность фаз (шагов).
Например, шаги для метода `post` таковы:

    'begin'   - начало
    'input'   - разбор HTTP-запроса
    'create'  - создание и заполнение Mongoose-документа
    'save'    - сохранение Mongoose-документа
    'output'  - выдача Mongoose-документа на клиент

Colibri строит из всех этих шагов цепочку прослоек для Express,
которые выполняются как асинхронный конвейер.

К счастью, в Colibri имеются средства для вмешательства в этот процесс.
Это делается с помощью метода `Resource#use`.
В него передается объект, в котором определяется в какой HTTP-метод и после какого из его шагов мы хотим вставить собственные функции-прослойки.

Именно это мы сделали, когда добавили нашу функцию `isAuthorized` в шаг `begin` методов `post`, `put` и `delete`.

Мы написали простейший плагин, который проверяет авторизацию.

Но с помощью API плагинов можно делать много других вещей.
Например, мы можем добавить сортировку списка документов в зависимости от входных параметров GET-запроса. Можем добавить автоматически заполняемые поля (например, ID автора статьи) в обработчик POST-запроса. Можем также реализовать более гибкую проверку правд доступа (например, сделать так, чтобы пользователь мог редактировать только свои статьи, а не чужие). И так далее.

### Резюме

Colibri по умолчанию создаёт простейший незащищённый,
но уже работоспособный REST-ресурс.
Задача разработчика приложения -
отсечь лишние возможности и добавить свои плюшки с помощью плагинов.

Документация по плагинам - TODO.

Готовые плагины - тоже пока TODO. В разработке - плагины `range` и `paginate`.

Документация по добавлению кастомных методов - TODO.